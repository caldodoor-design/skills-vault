---
name: debugging-systematically
description: バグ・テスト失敗・予期しない動作に遭遇した際、修正を提案する前に根本原因を体系的に調査するためのプロセス。推測による修正を防ぎ、確実な原因特定を行う。
trigger: バグ、テスト失敗、予期しない動作、パフォーマンス問題、ビルド失敗、統合問題に遭遇したとき
---

# 体系的デバッグ

## 概要

場当たり的な修正は時間の浪費であり、新たなバグを生む。応急処置は本質的な問題を隠蔽する。

**基本原則:** 修正を試みる前に、必ず根本原因を特定せよ。症状への対処は失敗である。

**このプロセスの形式的な違反は、デバッグの本質への違反である。**

## 鉄則

```
根本原因の調査なしに修正を行ってはならない
```

フェーズ1を完了していなければ、修正を提案してはならない。

## 適用タイミング

あらゆる技術的問題に使用する:
- テスト失敗
- 本番環境のバグ
- 予期しない動作
- パフォーマンス問題
- ビルド失敗
- 統合の問題

**特に以下の場合に使用すること:**
- 時間的プレッシャー下（緊急時ほど推測に走りがち）
- 「ちょっとした修正」が明白に見えるとき
- 既に複数の修正を試みた後
- 前回の修正がうまくいかなかったとき
- 問題を完全に理解していないとき

**省略してはならない場面:**
- 問題が単純に見える（単純なバグにも根本原因がある）
- 急いでいる（急ぐほど手戻りが増える）
- すぐに直せと言われている（体系的アプローチの方が速い）

## 4つのフェーズ

各フェーズを順番に完了すること。飛ばしてはならない。

### フェーズ1: 根本原因の調査

**修正を試みる前に必ず実施:**

1. **エラーメッセージを注意深く読む**
   - エラーや警告を読み飛ばさない
   - 正確な解決策が含まれていることが多い
   - スタックトレースを最後まで読む
   - 行番号、ファイルパス、エラーコードを記録する

2. **一貫した再現を行う**
   - 確実にトリガーできるか？
   - 正確な手順は？
   - 毎回発生するか？
   - 再現不可能な場合 → データを集める（推測しない）

3. **最近の変更を確認する**
   - 原因となり得る変更は何か？
   - `git diff`、最近のコミット
   - 新しい依存関係、設定変更
   - 環境の差異

4. **マルチコンポーネントシステムでの証拠収集**

   システムが複数のコンポーネントを持つ場合（CI → ビルド → 署名、API → サービス → DB）:

   **修正を提案する前に、診断用の計装を追加:**
   ```
   各コンポーネント境界について:
     - コンポーネントに入るデータをログ出力
     - コンポーネントから出るデータをログ出力
     - 環境/設定の伝播を検証
     - 各層の状態を確認

   一度実行して「どこで壊れるか」の証拠を収集
   → 証拠を分析して故障コンポーネントを特定
   → そのコンポーネントを重点調査
   ```

5. **データフローを追跡する**

   エラーがコールスタックの深部にある場合:
   - 不正な値はどこで発生したか？
   - 何がこの不正な値で呼び出したか？
   - 発生源に到達するまで遡り続ける
   - 症状ではなく発生源を修正する

### フェーズ2: パターン分析

**修正前にパターンを見つける:**

1. **動作する実例を探す**
   - 同じコードベース内で類似の動作するコードを見つける
   - 壊れているものと類似して動作しているものは何か？

2. **リファレンスと比較する**
   - パターンを実装する場合、リファレンス実装を完全に読む
   - 流し読みせず、すべての行を読む
   - 適用前にパターンを完全に理解する

3. **差異を特定する**
   - 動作するものと壊れているものの違いは何か？
   - どんなに小さくてもすべての違いをリストアップ
   - 「それは関係ない」と決めつけない

4. **依存関係を理解する**
   - 他にどのコンポーネントが必要か？
   - どの設定、構成、環境が必要か？
   - どのような前提条件があるか？

### フェーズ3: 仮説と検証

**科学的方法:**

1. **単一の仮説を立てる**
   - 明確に述べる:「Yの理由でXが根本原因だと考える」
   - 書き留める
   - 曖昧ではなく具体的に

2. **最小限のテストを行う**
   - 仮説を検証するための最小限の変更を行う
   - 一度に一つの変数だけ
   - 複数の修正を同時に行わない

3. **次に進む前に検証する**
   - うまくいった？ → フェーズ4へ
   - うまくいかない？ → 新しい仮説を立てる
   - 修正を重ねてはならない

4. **分からないとき**
   - 「Xが分からない」と言う
   - 知ったふりをしない
   - 助けを求める / さらに調査する

### フェーズ4: 実装

**症状ではなく根本原因を修正する:**

1. **失敗するテストケースを作成する**
   - 最もシンプルな再現
   - 可能であれば自動テスト
   - フレームワークがなければ単発のテストスクリプト
   - 修正前に必ず用意する

2. **単一の修正を実装する**
   - 特定された根本原因に対処する
   - 一度に一つの変更
   - 「ついでに」の改善はしない
   - リファクタリングを混ぜない

3. **修正を検証する**
   - テストが通るか？
   - 他のテストが壊れていないか？
   - 問題が実際に解決されたか？

4. **修正がうまくいかない場合**
   - 停止する
   - 試みた修正回数を数える
   - 3回未満: フェーズ1に戻り、新情報で再分析
   - **3回以上: 停止してアーキテクチャを疑う（下記5参照）**

5. **3回以上修正が失敗した場合: アーキテクチャを疑う**

   アーキテクチャ問題を示すパターン:
   - 各修正が新たな共有状態/結合/問題を別の場所で露呈する
   - 修正に「大規模リファクタリング」が必要
   - 各修正が別の場所で新たな症状を引き起こす

   **基本に立ち返る:**
   - このパターンは根本的に健全か？
   - 惰性で続けていないか？
   - 症状の修正を続けるべきか、アーキテクチャをリファクタリングすべきか？

   **これ以上の修正を試みる前にユーザーと議論すること。**

## 危険信号 - 停止してプロセスに従え

以下のような考えが浮かんだら:
- 「とりあえず今は応急処置で、調査は後で」
- 「Xを変えてうまくいくか試してみよう」
- 「複数の変更を加えてテストを実行しよう」
- 「テストは省略、手動で確認する」
- 「多分Xだろう、直そう」
- 「完全には理解していないがうまくいくかも」
- 「もう一回修正を試そう」（既に2回以上試行済み）

**すべて同じ意味: 停止。フェーズ1に戻れ。**

## よくある言い訳

| 言い訳 | 現実 |
|--------|------|
| 「単純な問題、プロセス不要」 | 単純なバグにも根本原因がある。プロセスも速い。 |
| 「緊急、プロセスの時間がない」 | 体系的デバッグの方が推測の繰り返しより速い。 |
| 「まずこれを試して、それから調査」 | 最初の修正がパターンを決める。最初から正しくやれ。 |
| 「修正確認後にテストを書く」 | テストなしの修正は定着しない。先にテスト。 |
| 「一度に複数修正で時間短縮」 | 何が効いたか分離不能。新バグの原因になる。 |
| 「リファレンスが長い、適当に応用」 | 部分的理解はバグを保証する。全部読め。 |
| 「もう一回修正を試そう」（2回以上失敗後） | 3回以上の失敗 = アーキテクチャ問題。 |

## クイックリファレンス

| フェーズ | 主な活動 | 成功基準 |
|---------|---------|---------|
| **1. 根本原因** | エラーを読む、再現、変更確認、証拠収集 | 何が・なぜを理解 |
| **2. パターン** | 動作例を探す、比較する | 差異を特定 |
| **3. 仮説** | 理論を立てる、最小限のテスト | 確認または新仮説 |
| **4. 実装** | テスト作成、修正、検証 | バグ解消、テスト通過 |

## 元リポジトリ

補助テクニック（root-cause-tracing, defense-in-depth, condition-based-waiting）の詳細:
→ https://github.com/obra/superpowers (skills/systematic-debugging/)
